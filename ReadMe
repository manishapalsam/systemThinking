
WEEK3: COUNCURRENCY & TRANSACTION  CHECK

->RACE CONDITION WHILE RESERVING INVENTORY :
    CLICK HERE (https://github.com/manishapalsam/systemThinking/blob/fdcfef033653d1dd5b68b06db31d78477b188f3b/RaceCondition_SnapShot.png)
    
    CONCURRENT REQUEST = 20
    P5 STOCK AVAILABILITY = 5
    ORDER CONFIRMED = 20
    P5 STOCK AVAILABILITY = 3

-> OPTIMISTIC LOCKING using @Version Annotation
  CLICK HERE (https://github.com/manishapalsam/systemThinking/blob/8e1ecc9d8bb7d3b76032a53106897dd11e1be7d6/Optimistic_Locking.png)
   
     CONCURRENT REQUEST = 10
    P5 STOCK AVAILABILITY = 5
    ORDER CONFIRMED = 1, OTHER 9 CONCURRENT REQUEST FAILED
     P5 STOCK AVAILABILITY = 4
    

->DOUBLE REFUND SITUATION UNDER CONCURRENCY
  CLICK HERE: (https://github.com/manishapalsam/systemThinking/blob/7180bcfc16b0621592a62c7b851bc53a02cb8a19/DoubleRefund.png)
  Two concurrent requests hit the refund API at the same time.

    Thread Execution:
    Thread A → No refund found -> Thread Sleep(10000)
    Thread B →  No refund found -> Thread Sleep(10000)

    Both threads pass the check.
    Both insert refund records.

     Result in Database:
    Two refund rows
    Same order_id
    Different refund_id


    -> UNIQUE DB CONSTARINT FOR TABLE "REFUNDS"

    EG: @Entity
        @Table(
            name = "refunds",
            uniqueConstraints = {
                @UniqueConstraint(columnNames = {"order_id"})
            }
        )

CLICK HERE : (https://github.com/manishapalsam/systemThinking/blob/d16df1db9f198be3f627eba2a82a9039ec5e5a0d/UniqueConstraint.png)
        Now:
            Race condition still exists
            But DB prevented data corruption
       This is important:
            We did NOT remove race condition.
            We prevented duplicate state.
    



