
WEEK3: COUNCURRENCY & TRANSACTION  CHECK

->RACE CONDITION WHILE RESERVING INVENTORY :
    CLICK HERE (https://github.com/manishapalsam/systemThinking/blob/fdcfef033653d1dd5b68b06db31d78477b188f3b/RaceCondition_SnapShot.png)
    
    CONCURRENT REQUEST = 20
    P5 STOCK AVAILABILITY = 5
    ORDER CONFIRMED = 20
    P5 STOCK AVAILABILITY = 3

-> OPTIMISTIC LOCKING using @Version Annotattion
  CLICK HERE (https://github.com/manishapalsam/systemThinking/blob/8e1ecc9d8bb7d3b76032a53106897dd11e1be7d6/Optimistic_Locking.png)
   
     CONCURRENT REQUEST = 10
    P5 STOCK AVAILABILITY = 5
    ORDER CONFIRMED = 1, OTHER 9 CONCURRENT REQUEST FAILED
     P5 STOCK AVAILABILITY = 4
    


    



===================================================
ğŸ“Œ14-2-26
 Circular Dependency Error â€“ Short Notes
ğŸ”¹ What Is Circular Dependency?

When two Spring beans depend on each other.

Example:

InventoryService â†’ InventoryTransactionService
InventoryTransactionService â†’ InventoryService


This creates a loop.

Spring cannot decide which one to create first.

ğŸ”¹ Why Spring Fails to Start?

Spring creates beans at startup.

If:

Bean A needs Bean B
Bean B needs Bean A


Spring gets stuck in infinite creation loop.

So modern Spring Boot blocks it by default.

Error:

Relying upon circular references is discouraged

ğŸ”¹ Why It Happened In Our Case?

We injected:

@Autowired
private InventoryTransactionService transactionService;


inside InventoryService

AND

@Autowired
private InventoryService inventoryService;


inside InventoryTransactionService

That created:

Service A â†” Service B

ğŸ”¹ How To Fix It?

âœ” Remove one dependency
âœ” Only one direction allowed

Correct structure:

Controller
   â†“
InventoryService (retry logic)
   â†“
InventoryTransactionService (@Transactional)
   â†“
Repository


âŒ TransactionService must NOT depend on InventoryService.

ğŸ”¹ Important Rule

If A depends on B,
B must NOT depend on A.

ğŸ”¹ Bad Solution (Do NOT Use)
spring.main.allow-circular-references=true


This hides bad design.

Always fix architecture instead.