ðŸ“˜ 15-02-26 â€” Double Refund (Exactly-Once Failure)
ðŸ”¹ Scenario

Customer reported they received refund twice.
Application logs looked clean.
No exceptions were thrown.

ðŸ”¹ Refund API Implementation (Bad Version)
Flow:

Load Order by ID

Check if refund already exists

If exists â†’ throw error

If not â†’ create refund record

Save refund

Return success

This logic looks correct.

This is how most developers implement it.

But it is broken under concurrency.

ðŸ”¹ Where the Race Condition Happens

Two concurrent requests hit the refund API at the same time.

Thread Execution:

Thread A â†’ Step 2 â†’ No refund found
Thread B â†’ Step 2 â†’ No refund found

Both threads pass the check.
Both insert refund records.

ðŸ”¹ Result in Database

Two refund rows

Same order_id

Different refund_id

ðŸ”¹ Observed Symptoms

API returned 200 OK for both calls

No exception thrown

Logs looked clean

Finance mismatch occurred

ðŸ”¹ Root Cause

This is a check-then-act race condition.

The check (findByOrderId) and the insert (save) were not atomic.

There was no:

Unique constraint

Locking

Idempotency guard

Two concurrent transactions passed the existence check before either inserted the refund.

ðŸ”¹ Why Logs Look Clean?

Each transaction was individually valid.

There was no database constraint violation.

The race condition occurred between the check and insert steps.

ðŸ”¹ Concept Learned
Check-Then-Act problem
Non-idempotent API
Exactly-Once failure
Transactions alone do NOT guarantee correctness under concurrency:
   -> Transactions â‰  Concurrency Control
        Why?
    Because transactions ensure atomicity per request(either execute or fail), but do not prevent race conditions between multiple requests.
    In My Case:
    Both transactions checked refund existence before either inserted â†’ duplicate refund created.