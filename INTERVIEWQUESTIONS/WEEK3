



===================================================
ðŸ“Œ14-2-26
 Circular Dependency Error â€“ Short Notes
ðŸ”¹ What Is Circular Dependency?

When two Spring beans depend on each other.

Example:

InventoryService â†’ InventoryTransactionService
InventoryTransactionService â†’ InventoryService


This creates a loop.

Spring cannot decide which one to create first.

ðŸ”¹ Why Spring Fails to Start?

Spring creates beans at startup.

If:

Bean A needs Bean B
Bean B needs Bean A


Spring gets stuck in infinite creation loop.

So modern Spring Boot blocks it by default.

Error:

Relying upon circular references is discouraged

ðŸ”¹ Why It Happened In Our Case?

We injected:

@Autowired
private InventoryTransactionService transactionService;


inside InventoryService

AND

@Autowired
private InventoryService inventoryService;


inside InventoryTransactionService

That created:

Service A â†” Service B

ðŸ”¹ How To Fix It?

âœ” Remove one dependency
âœ” Only one direction allowed

Correct structure:

Controller
   â†“
InventoryService (retry logic)
   â†“
InventoryTransactionService (@Transactional)
   â†“
Repository


âŒ TransactionService must NOT depend on InventoryService.

ðŸ”¹ Important Rule

If A depends on B,
B must NOT depend on A.

ðŸ”¹ Bad Solution (Do NOT Use)
spring.main.allow-circular-references=true


This hides bad design.

Always fix architecture instead.




ðŸ“˜ 15-02-26 â€” Double Refund (Exactly-Once Failure)
ðŸ”¹ Scenario

Customer reported they received refund twice.
Application logs looked clean.
No exceptions were thrown.

ðŸ”¹ Refund API Implementation (Bad Version)
Flow:

Load Order by ID

Check if refund already exists

If exists â†’ throw error

If not â†’ create refund record

Save refund

Return success

This logic looks correct.

This is how most developers implement it.

But it is broken under concurrency.

ðŸ”¹ Where the Race Condition Happens

Two concurrent requests hit the refund API at the same time.

Thread Execution:

Thread A â†’ Step 2 â†’ No refund found
Thread B â†’ Step 2 â†’ No refund found

Both threads pass the check.
Both insert refund records.

ðŸ”¹ Result in Database

Two refund rows

Same order_id

Different refund_id

ðŸ”¹ Observed Symptoms

API returned 200 OK for both calls

No exception thrown

Logs looked clean

Finance mismatch occurred

ðŸ”¹ Root Cause

This is a check-then-act race condition.

The check (findByOrderId) and the insert (save) were not atomic.

There was no:

Unique constraint

Locking

Idempotency guard

Two concurrent transactions passed the existence check before either inserted the refund.

ðŸ”¹ Why Logs Look Clean?

Each transaction was individually valid.

There was no database constraint violation.

The race condition occurred between the check and insert steps.

ðŸ”¹ Concept Learned
Check-Then-Act problem
Non-idempotent API
Exactly-Once failure
Transactions alone do NOT guarantee correctness under concurrency:
   -> Transactions â‰  Concurrency Control
        Why?
    Because transactions ensure atomicity per request(either execute or fail), but do not prevent race conditions between multiple requests.
    In My Case:
    Both transactions checked refund existence before either inserted â†’ duplicate refund created.